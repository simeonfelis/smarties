<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Smarties2: Smarties2 software</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Smarties2 software</h1>
<p>
<h3 align="center">0.9 </h3><h2><a class="anchor" name="intro">
License</a></h2>
GPL2 Licence<h2><a class="anchor" name="install">
Description</a></h2>
This is the Source code's API and flow documentation for Smarties2<h2><a class="anchor" name="arch">
Architecture</a></h2>
Goal of this application is a state machine controlled by status flags. The <a class="el" href="smarties2_8c.html#840291bc02cba5474a4cb46a9b9566fe" title="Entry functin for smarties2.">main()</a> function controls the program flow by reading and setting status flags. These status flags are polled each millisecond in an timer interrupt routine. This timer interrupt routine reads and sets the IO ports and sets corresponding status flags.<p>
Following image clarifies the structure of the software:<p>
<div align="center">
<img src="api-layer.png" alt="api-layer.png">
<p><strong>Layers of the software stack</strong></p></div>
 <p>
The task of the differen layers, high level, abstraction layer and low level can be described like in following image:<p>
<div align="center">
<img src="state-machine.png" alt="state-machine.png">
<p><strong>Executing the different layers</strong></p></div>
 <p>
The state machine is devided into two sections, the mode and steps. Modes are represented as an enum <a class="el" href="system_8h.html#6e4cea4b6246f491c526211f5405627d">system_mode_t</a> and the steps as an struct <a class="el" href="structsystem__step__t.html">system_step_t</a><p>
The modes are changed depending on the user inputs or after powering on/reseting. The next picture clarifies the modes of the state machine.<p>
<div align="center">
<img src="state-machine-modes.png" alt="state-machine-modes.png">
<p><strong>State diagram of the smartie sorter</strong></p></div>
 <p>
The mode <a class="el" href="system_8h.html#6e4cea4b6246f491c526211f5405627d564529220e61e848983d8eb9d7f87736">SYS_MODE_RUNNING</a> equals the automatic mode, where everything is controlled in several steps. The last step, step III, is a transition step to begin from the start again. See next picture for the overview of the steps.<p>
<div align="center">
<img src="state-machine-steps.png" alt="state-machine-steps.png">
<p><strong>Executing steps of the mode SYS_MODE_RUNNING</strong></p></div>
 <p>
Each steps starts several tasks and waits until they are finished. Then the next step will be entered.<p>
To see what is happening exactly in the different steps, please have a look at the sourcecode.<p>
The modes, steps and all input/output related parts of the Smartie sorter are administrated within structs. The structs are organized like in the following picture.<p>
<div align="center">
<img src="structsmartie__sorter__t__coll__graph.png" alt="structsmartie__sorter__t__coll__graph.png">
<p><strong>Brief overview of several objects (elements) of the smartie sorter</strong></p></div>
 <p>
For the detailed overview and description please refere to the code and documentation of <a class="el" href="structsmartie__sorter__t.html">smartie_sorter_t</a>.<p>
The system related IO actions are all defined in <a class="el" href="system_8h.html">system.h</a> There are controlled<ul>
<li>moving the revolver</li><li>moving the catcher</li><li>user input controlls</li></ul>
<p>
Minor configurations are made in <a class="el" href="smarties2_8h.html">smarties2.h</a><h2><a class="anchor" name="prog_flow">
Progam flow</a></h2>
The application entry point is located at <a class="el" href="smarties2_8c.html#840291bc02cba5474a4cb46a9b9566fe">main()</a> in <a class="el" href="smarties2_8c.html">smarties2.c</a> file.<ul>
<li>The main function first performs the initialization</li><li>It handles the modes of the smartie sorter</li><li>It handles the state machine</li><li>It handles the programs executed by the menu during <a class="el" href="system_8h.html#6e4cea4b6246f491c526211f5405627df1c8a041b6d3d46002d02ed0645a8ba2">SYS_MODE_PAUSE</a></li></ul>
<p>
The LCD controlling is done with the <a class="el" href="lcd__display_8h.html">lcd_display.h</a><p>
The Menu structure is described in <a class="el" href="menu_8h.html">menu.h</a><h2><a class="anchor" name="col_detect">
Color detection</a></h2>
The color sensor TCS230 delivers 4 output values:<ul>
<li>Blue (with blue filter)</li><li>Green (with green filter)</li><li>Red (with red filter)</li><li>Brigthness (with no filter)</li></ul>
<p>
The smartie color detection is done by calculating the smallest distance to a next smartie.<p>
For reference measures some values for each channel are recorded to gain a avarage value. They can be represented in an 3 Dimensional graph. For color detection the avarage value for each channel is used.<p>
<div align="center">
<img src="plot_tilted_2.png" alt="plot_tilted_2.png">
<p><strong>Smartie color RGB valus</strong></p></div>
 <div align="center">
<img src="plot_top.png" alt="plot_top.png">
<p><strong>Smartie color RGB valus from top</strong></p></div>
 <div align="center">
<img src="plot_front.png" alt="plot_front.png">
<p><strong>Smartie color RGB valus from front</strong></p></div>
 <div align="center">
<img src="plot_side.png" alt="plot_side.png">
<p><strong>Smartie color RGB valus from side</strong></p></div>
<p>
   <p>
If a smartie color's red, green and blue cannel are measured the distance to each reference smartie is worked out by following formula:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ Distance = \sqrt{ ( {blue_{new} - blue_{ava} } )^2 + { (green_{new} - green_{ava} })^2 + { ( red_{new} - red_{ava} })^2 } \]" src="form_3.png">
<p>
<p>
The smartie sorter uses reference values which are gained during this software development. However the user can callibrate the reference values new without destroying the system default values.<p>
The color tables with avarage values are stored in the EEprom memory. In the EEProm memory there are stored system default values as well as newly callibrated values. When the system default values are restored, all callibrated colors are overwritten.<p>
Only the blue, green and red channel is respected. A survey brought up that the brightness of the surrounding has no influence to the color measurent. The most important factor is temperature, as the smarties fat drifts out when they are getting to warm (above 24 Deg C). Then, the smartie's colors become brighter.<h2><a class="anchor" name="adv_col_det">
Advanced color detecection</a></h2>
The first try with color detectin was made with reference tables. For each smartie was a minimum and maximum value for each channel stored. However, this method was too unrelyable.<p>
More methods for calculating the correct smartie color are prepared in the code. They can be enabled by compiler switches. Enabling all methods could possible fill all data memory, as a lot of reference data is necessary, which are preferable stored as floats.<p>
Another try was to calculate the normalized distance from the new, unknown smartie to the reference values. However this method didn't show good results, probably because the Orange, Red, Pink and Brown smarties are nearly all on a vector in one direction (see figure above or the 3D gnuplot).<p>
Another idea (not implemented) for color detecting was respecting the color drift of smarties with the temperature. To respect this, smarties must be mesured in a temperature range from 15 Deg C to 25 Deg C and measure the unfilterd color channel (Brightness). Then, estimate the polynomial function of the three channels blue, green, red with the brightness as coefficient. The result is a curve in a 3 Dimensional space for each smartie color, and the axes are the three color channels. The next step is to calculate the orthogonal distance from a new, unknown smartie to all the curves. The curve which has the smallest orthogonal distance should belong to the corresponding smartie.<p>
With this method it could also be possible to estimate the temperature of the surrounding, not with +-1 Deg C, but you could say that the surrounding is cold, warm or too warm. Maybe too warm for smarties, which should be kept below 25 Deg C.<h2><a class="anchor" name="Programs">
Programs</a></h2>
During <a class="el" href="system_8h.html#6e4cea4b6246f491c526211f5405627df1c8a041b6d3d46002d02ed0645a8ba2">SYS_MODE_PAUSE</a> various programs can be started from the menu. For controlling the state machines programs, the enum <a class="el" href="system_8h.html#6cfd37e27dfa4a49be0ab6d983f4fc55">program_t</a> is used.<p>
Usually programs are executed completely in the background and only their progress or results are displayed during the state machine proceeds.<p>
However, Programs can also take control over the user inputs and display. Some programs need to be completely finished before the state machine may proceed (e. g. <a class="el" href="system_8h.html#6cfd37e27dfa4a49be0ab6d983f4fc55e7156e0e78e0f3ce9f2ce0d7bbe8bac5">prog_set_colors_blue</a>)<p>
The state of programs are controlled in <a class="el" href="smarties2_8c.html#840291bc02cba5474a4cb46a9b9566fe">main()</a> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Aug 29 13:48:09 2008 for Smarties2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
